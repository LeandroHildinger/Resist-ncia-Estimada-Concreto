<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análise Preditiva de Resistência do Concreto</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>
    <!-- Bibliotecas para Exportação PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
        
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .katex { font-size: 1.1em; }
        .modal-overlay { transition: opacity 0.3s ease; }
        .modal-content { transition: transform 0.3s ease; }
                
        /* Estilos para Tooltip */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }
        .tooltip-icon {
            cursor: pointer;
            margin-left: 4px;
            color: #6b7280;
        }
        .tooltip-text {
            visibility: hidden;
            width: 220px;
            background-color: #1f2937;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -110px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem;
            line-height: 1.2;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #1f2937 transparent transparent transparent;
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-xl sm:text-2xl lg:text-3xl font-bold text-gray-900">Análise Preditiva de Resistência</h1>
            <p class="text-sm sm:text-base text-gray-600 mt-2">Estime a resistência do concreto com base em ensaios de laboratório.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <!-- Coluna do Gráfico -->
            <div id="captureArea" class="lg:col-span-2 bg-white p-4 sm:p-6 rounded-xl shadow-lg h-auto">
                <canvas id="resistanceChart" class="h-96 lg:h-auto"></canvas>
            </div>

            <!-- Coluna de Controles -->
            <div class="bg-white p-4 sm:p-6 rounded-xl shadow-lg flex flex-col space-y-6">
                
                <!-- Seção de Parâmetros -->
                <div>
                    <h2 class="text-lg font-semibold border-b pb-2 mb-4">Parâmetros da Análise</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="fckInput" class="block text-sm font-medium text-gray-700">Resistência de Projeto (fck)</label>
                            <div class="mt-1 flex items-center">
                                <input type="number" id="fckInput" value="25" min="10" max="150" class="w-full bg-gray-50 border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <span class="ml-2 text-gray-500">MPa</span>
                            </div>
                        </div>
                        <div>
                            <div class="flex items-center">
                                <label for="sdInput" class="block text-sm font-medium text-gray-700">Desvio Padrão de Dosagem (sd)</label>
                                <div class="tooltip-container">
                                    <span class="tooltip-icon">ⓘ</span>
                                    <span class="tooltip-text">Valor conforme NBR 12655. Usar 4.0 MPa para condição A (laboratório/concreteira com controle rigoroso). Mínimo de 2.0 MPa.</span>
                                </div>
                            </div>
                            <div class="mt-1 flex items-center">
                                <input type="number" id="sdInput" step="0.1" min="2.0" placeholder="Padrão: 4.0 MPa" class="w-full bg-gray-50 border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <span class="ml-2 text-gray-500">MPa</span>
                            </div>
                        </div>
                        <div>
                            <label for="cementType" class="block text-sm font-medium text-gray-700">Tipo de Cimento (NBR 6118)</label>
                            <select id="cementType" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <option value="0.25" selected>CP I / CP II (Ganho Normal)</option>
                                <option value="0.38">CP III / CP IV (Ganho Lento)</option>
                                <option value="0.20">CP V-ARI (Ganho Rápido)</option>
                                <option value="custom">Personalizado (Impor 's')</option>
                            </select>
                        </div>
                        <div id="customSContainer" class="hidden">
                            <label for="customSInput" class="block text-sm font-medium text-gray-700">Coeficiente 's' Personalizado</label>
                            <div class="mt-1 flex items-center">
                                <input type="number" id="customSInput" step="0.01" min="0.05" max="0.6" value="0.25" class="w-full bg-gray-50 border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                            </div>
                        </div>
                         <div>
                            <label for="analysisMode" class="block text-sm font-medium text-gray-700">Modo de Análise da Curva</label>
                            <select id="analysisMode" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <option value="adjusted">Regressão Otimizada (Padrão)</option>
                                <option value="normative">Forçar Curva Normativa</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Seção de Dados -->
                <div class="flex-grow">
                    <h2 class="text-lg font-semibold border-b pb-2 mb-4">Resultados dos Ensaios</h2>
                    <div class="overflow-x-auto max-h-48">
                        <table class="min-w-full">
                            <thead>
                                <tr>
                                    <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 uppercase">Idade</th>
                                    <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 uppercase">Resistência</th>
                                    <th class="px-2 py-2 text-right text-xs font-medium text-gray-500 uppercase">Ação</th>
                                </tr>
                            </thead>
                            <tbody id="dataTableBody" class="bg-white">
                                <!-- Linhas de dados serão inseridas aqui via JS -->
                            </tbody>
                        </table>
                    </div>
                    <div class="flex gap-2 mt-4">
                        <button id="addPointBtn" class="w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-150 ease-in-out text-sm font-medium">
                            Adicionar
                        </button>
                                                
                        <div class="w-full relative">
                            <button id="importCsvBtn" class="w-full bg-gray-200 text-gray-700 py-2 px-4 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 transition duration-150 ease-in-out text-sm font-medium pr-8 text-center">
                                Importar CSV
                            </button>
                            <div class="tooltip-container absolute top-0 right-0 h-full flex items-center pr-3">
                                <span class="tooltip-icon">ⓘ</span>
                                <span class="tooltip-text" style="width: 260px; margin-left: -130px; text-align: left; padding: 10px; bottom: 115%;">
                                    <b>Formato do Arquivo CSV:</b><br>
                                    - Duas colunas: `idade,resistencia`<br>
                                    - Separador: vírgula (,) ou ponto e vírgula (;)<br>
                                    - A primeira linha (cabeçalho) é ignorada.
                                </span>
                            </div>
                        </div>

                        <input type="file" id="csvFileInput" class="hidden" accept=".csv">
                    </div>
                </div>

                <!-- Seção de Resultados -->
                <div class="mt-2">
                    <h2 class="text-lg font-semibold border-b pb-2 mb-4">Resultados e Ações</h2>
                    <div id="guidanceBox" class="p-3 mb-4 text-sm rounded-lg"></div>
                    <!-- NOVO: Container para exclusão automática -->
                    <div class="flex items-start gap-2 mb-2">
                        <input type="checkbox" id="autoDropToggle" class="mt-1">
                        <label for="autoDropToggle" class="text-sm text-gray-700">
                            Excluir automaticamente, no <b>ajuste</b>, o ponto menos conservador de pares fora da banda
                        </label>
                    </div>
                    <div id="excludedList" class="hidden text-xs text-gray-600 mb-4 p-2 bg-gray-100 rounded"></div>
                    <div id="warningsBox" class="hidden space-y-2 mb-4"></div>
                    <div id="trendGuidanceBox" class="hidden"></div>
                    <div id="delta28Box" class="hidden p-3 mb-4 text-sm rounded-lg"></div>
                    <div class="space-y-2 p-4 bg-indigo-50 rounded-lg">
                        <div>
                            <label for="predictionDays" class="block text-sm font-medium text-indigo-800">Calcular fck,est para:</label>
                            <div class="mt-1 flex items-center">
                                <input type="number" id="predictionDays" placeholder="Ex: 28" class="w-full bg-white border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <span class="ml-2 text-gray-500">dias</span>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-indigo-800">Resistência Característica Estimada</label>
                            <div id="predictedResistance" class="mt-1 text-xl font-bold text-red-700">-- MPa</div>
                        </div>
                        <div id="predictedPlausibleTrendResistanceContainer" class="hidden pt-2 border-t border-indigo-200">
                            <label class="block text-sm font-medium text-green-800">Tendência Plausível (s restrito)</label>
                            <div id="predictedPlausibleTrendResistance" class="mt-1 text-lg font-bold text-green-700">-- MPa</div>
                        </div>
                        <div id="predictedFreeTrendResistanceContainer" class="hidden pt-2 border-t border-indigo-200">
                            <label class="block text-sm font-medium text-purple-800">Tendência Livre (s livre)</label>
                            <div id="predictedFreeTrendResistance" class="mt-1 text-lg font-bold text-purple-700">-- MPa</div>
                        </div>
                    </div>
                    <div class="flex flex-col gap-2 mt-4">
                        <button id="generateReportBtn" class="w-full bg-gray-700 text-white py-2 px-4 rounded-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition duration-150 ease-in-out text-sm font-medium disabled:bg-gray-400" disabled>
                            Gerar Relatório
                        </button>
                        <button id="exportPdfBtn" class="w-full bg-red-600 text-white py-2 px-4 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition duration-150 ease-in-out text-sm font-medium disabled:bg-red-400" disabled>
                            Exportar PDF
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Seção de Equações -->
        <div id="equationsSection" class="mt-8 bg-white p-4 sm:p-6 rounded-xl shadow-lg hidden">
            <h2 class="text-lg font-semibold border-b pb-2 mb-4">Equações Aplicadas</h2>
            <div class="space-y-4 text-sm">
                <div>
                    <h3 class="font-semibold text-gray-700">Curva de Referência (Teórica)</h3>
                    <div id="theoreticalEquation" class="mt-2 p-2 bg-gray-50 rounded"></div>
                </div>
                <div>
                    <h3 class="font-semibold text-gray-700">Curva Característica (Estimada)</h3>
                    <div id="characteristicEquation" class="mt-2 p-2 bg-gray-50 rounded"></div>
                </div>
                <div id="plausibleTrendEquationContainer" class="hidden">
                    <h3 class="font-semibold text-gray-700">Curva de Tendência Plausível (s restrito)</h3>
                    <div id="plausibleTrendEquation" class="mt-2 p-2 bg-gray-50 rounded"></div>
                </div>
                <div id="freeTrendEquationContainer" class="hidden">
                    <h3 class="font-semibold text-gray-700">Curva de Tendência Livre (s livre)</h3>
                    <div id="freeTrendEquation" class="mt-2 p-2 bg-gray-50 rounded"></div>
                </div>
            </div>
        </div>

        <footer class="text-center text-xs text-gray-500 py-6 mt-4">
            Desenvolvido por Leandro Hildinger Cavalcanti
        </footer>
    </div>

    <!-- Modal de Relatório -->
    <div id="reportModal" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0 z-50">
        <div class="modal-content bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto transform scale-95">
            <div class="sticky top-0 bg-white border-b p-4 flex justify-between items-center">
                <h2 class="text-xl font-bold text-gray-800">Relatório de Análise Interpretativa</h2>
                <button id="closeReportBtn" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <div id="reportContent" class="p-6 space-y-4 text-gray-700"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        
        const Beta = {
            beta1(t, s){ return Math.exp(s*(1 - Math.sqrt(28/t))); },
            f28_from_point(mpa_t, t, s){ return mpa_t / this.beta1(t, s); }
        };

        const DataValidator = {
            alphaConfig: [
                {p1:2, p2:3, alpha:0.20, label:'3d/2d'},
                {p1:3, p2:7, alpha:0.20, label:'7d/3d'},
                {p1:7, p2:14, alpha:0.12, label:'14d/7d'},
                {p1:14, p2:28, alpha:0.10, label:'28d/14d'}
            ],

            checkAll(dataPoints, s_normative) {
                if (dataPoints.length < 2) return [];
                const sortedData = [...dataPoints].sort((a, b) => a.days - b.days);
                const monotonicityWarnings = this.checkMonotonicity(sortedData);
                const ratioWarnings = this.checkRatios(sortedData, s_normative);
                return [...monotonicityWarnings, ...ratioWarnings];
            },

            checkMonotonicity(sortedData) {
                const warnings = [];
                for (let i = 1; i < sortedData.length; i++) {
                    if (sortedData[i].mpa < sortedData[i - 1].mpa) {
                        warnings.push(`<b>Inconsistência de Monotonia:</b> A resistência aos ${sortedData[i].days} dias (${sortedData[i].mpa.toFixed(1)} MPa) é menor que a dos ${sortedData[i - 1].days} dias (${sortedData[i - 1].mpa.toFixed(1)} MPa).`);
                    }
                }
                return warnings;
            },
            
            checkRatios(sortedData, s_normative) {
                const warnings = [];
                const byDay = Object.fromEntries(sortedData.map(p => [p.days, p.mpa]));

                this.alphaConfig.forEach(({p1,p2,alpha,label})=>{
                    if(!(byDay[p1]>0 && byDay[p2]>0)) return;
                    const r_obs = byDay[p2]/byDay[p1];
                    const r_exp = Beta.beta1(p2, s_normative)/Beta.beta1(p1, s_normative);
                    const low = r_exp*(1-alpha), high = r_exp*(1+alpha);
                    if(r_obs<low || r_obs>high){
                        warnings.push(`<b>Razão ${label} Incomum:</b> O valor de ${r_obs.toFixed(2)} está fora da banda dinâmica esperada (${low.toFixed(2)} a ${high.toFixed(2)}).`);
                    }
                });
                return warnings;
            },

            suggestDropsForFit(sortedData, s_normative){
                const drops = new Set();
                const byDay = Object.fromEntries(sortedData.map(p => [p.days, p.mpa]));
                this.alphaConfig.forEach(({p1,p2,alpha})=>{
                    if(!(byDay[p1]>0 && byDay[p2]>0)) return;
                    const r_obs = byDay[p2]/byDay[p1];
                    const r_exp = Beta.beta1(p2, s_normative)/Beta.beta1(p1, s_normative);
                    const low = r_exp*(1-alpha), high = r_exp*(1+alpha);
                    if(r_obs<low || r_obs>high){
                        const f28_1 = Beta.f28_from_point(byDay[p1], p1, s_normative);
                        const f28_2 = Beta.f28_from_point(byDay[p2], p2, s_normative);
                        if (Math.abs(f28_1 - f28_2)/Math.max(f28_1,f28_2) < 0.03){
                            drops.add(Math.min(p1,p2)); 
                        } else {
                            drops.add(f28_1 > f28_2 ? p1 : p2);
                        }
                    }
                });
                return [...drops];
            }
        };

        const Calculator = {
            validateInput(value, name, min = -Infinity, max = Infinity) {
                const numValue = parseFloat(value);
                if (isNaN(numValue)) throw new Error(`Parâmetro "${name}" deve ser um número.`);
                if (numValue < min) throw new Error(`Parâmetro "${name}" deve ser no mínimo ${min}.`);
                if (numValue > max) throw new Error(`Parâmetro "${name}" deve ser no máximo ${max}.`);
                return numValue;
            },

            calculateResistance: (fcm, s, t) => {
                if (t <= 0) return 0;
                return fcm * Math.exp(s * (1 - Math.sqrt(28 / t)));
            },

            generateCurveData(fcm, s, maxDays = 90) {
                const data = [];
                for (let t = 1; t <= maxDays; t += 0.5) {
                    data.push({ x: t, y: this.calculateResistance(fcm, s, t) });
                }
                data.sort((a, b) => a.x - b.x);
                return data;
            },
            
            goldenSection(min, max, fn, tol=1e-4, maxIter=60){
              const gr = (Math.sqrt(5)-1)/2;
              let a=min, b=max, c=b-gr*(b-a), d=a+gr*(b-a);
              let fc=fn(c), fd=fn(d);
              for(let i=0;i<maxIter && Math.abs(b-a)>tol;i++){
                if(fc>fd){ a=c; c=d; fc=fd; d=a+gr*(b-a); fd=fn(d); }
                else     { b=d; d=c; fd=fc; c=b-gr*(b-a); fc=fn(c); }
              }
              return (a+b)/2;
            },

            findBestFitParameters(dataPoints, s_min, s_max){
                if (dataPoints.length < 2) return null;
                const sse = (s) => {
                    const fcm = this.findBestFitFcm(dataPoints, s);
                    if (fcm === null) return Infinity;
                    return dataPoints.reduce((acc,p)=>{
                        const pred = this.calculateResistance(fcm, s, p.days);
                        return acc + (p.mpa - pred)**2;
                    },0);
                };
                const s_opt = this.goldenSection(s_min, s_max, sse);
                return { s: s_opt, fcm: this.findBestFitFcm(dataPoints, s_opt) };
            },
            
            findTrulyBestFitParameters(dataPoints) {
                if (dataPoints.length < 2) return null;
                return this.findBestFitParameters(dataPoints, 0.05, 0.60);
            },

            findBestFitFcm(dataPoints, s) {
                if (dataPoints.length < 1) return null;
                let numerator = 0;
                let denominator = 0;
                dataPoints.forEach(point => {
                    if (point.days > 0) {
                        const k = Math.exp(s * (1 - Math.sqrt(28 / point.days)));
                        numerator += point.mpa * k;
                        denominator += k * k;
                    }
                });
                return denominator > 0 ? numerator / denominator : null;
            },
            
            computeOffsetResiduals(data, fcm, s){
                const res = data.map(p => this.calculateResistance(fcm, s, p.days) - p.mpa);
                const positives = res.filter(x=>x>0).sort((a,b)=>a-b);
                const maxPos = positives.length? positives[positives.length-1] : 0;
                const p95 = positives.length? positives[Math.floor(0.95*(positives.length-1))] : 0;
                return {maxPos, p95};
            },

            performAnalysis(state) {
                const { fck, sd, s_normative, realData, analysisMode } = state;
                const fcm_base = fck + 1.65 * sd;
                                
                let s_final = s_normative;
                let fcm_final = fcm_base;
                let safetyOffset = 0;
                let ruleApplied = false;
                                
                let plausibleTrendFcm = fcm_base;
                let plausibleTrendS = s_normative;
                let plausibleTrendOffset = 0;
                let showPlausibleTrendCurve = false;
                let tendencySuperiority = 0;

                let freeTrendFcm = fcm_base;
                let freeTrendS = s_normative;
                let freeTrendOffset = 0;
                let showFreeTrendCurve = false;

                if (realData.length > 0) {
                    if (analysisMode === 'adjusted' && realData.length > 1) {
                        const s_range_offset = 0.03;
                        const s_min_plausible = Math.max(0.05, s_normative - s_range_offset);
                        const s_max_plausible = s_normative + s_range_offset;

                        const bestFitPlausible = this.findBestFitParameters(realData, s_min_plausible, s_max_plausible);
                        if (bestFitPlausible) {
                             plausibleTrendS = bestFitPlausible.s;
                             plausibleTrendFcm = bestFitPlausible.fcm;
                        }
                        const bestFitFree = this.findTrulyBestFitParameters(realData);
                        if (bestFitFree) {
                            freeTrendS = bestFitFree.s;
                            freeTrendFcm = bestFitFree.fcm;
                        }

                    } else if (analysisMode === 'normative' || realData.length <= 1) {
                         plausibleTrendFcm = this.findBestFitFcm(realData, plausibleTrendS) || fcm_base;
                         freeTrendFcm = plausibleTrendFcm;
                    }

                    if (plausibleTrendFcm > fcm_base) {
                        showPlausibleTrendCurve = true;
                        const fcm_ref_28 = this.calculateResistance(fcm_base, s_normative, 28);
                        const fcm_plausible_28 = this.calculateResistance(plausibleTrendFcm, plausibleTrendS, 28);
                        if (fcm_ref_28 > 0) {
                            tendencySuperiority = ((fcm_plausible_28 / fcm_ref_28) - 1) * 100;
                        }
                        plausibleTrendOffset = this.computeOffsetResiduals(realData, plausibleTrendFcm, plausibleTrendS).maxPos;
                    }
                    
                    if (freeTrendFcm > fcm_base && analysisMode === 'adjusted') {
                        showFreeTrendCurve = true;
                        freeTrendOffset = this.computeOffsetResiduals(realData, freeTrendFcm, freeTrendS).maxPos;
                    }

                    let reg_fcm_limited = Math.min(plausibleTrendFcm, fcm_base);
                    let reg_s_final = plausibleTrendS;
                                        
                    let shouldUseTheoretical = false;
                    if (realData.length > 1 && analysisMode === 'adjusted') {
                        let isRefCurveBelowAllPoints = true;
                        let sse_ref = 0;
                        realData.forEach(point => {
                            const predicted_ref = this.calculateResistance(fcm_base, s_normative, point.days);
                            if (point.mpa < predicted_ref) { isRefCurveBelowAllPoints = false; }
                            sse_ref += Math.pow(point.mpa - predicted_ref, 2);
                        });

                        if (isRefCurveBelowAllPoints) {
                            let sse_reg = 0;
                            realData.forEach(point => {
                                const predicted_reg = this.calculateResistance(reg_fcm_limited, reg_s_final, point.days);
                                sse_reg += Math.pow(point.mpa - predicted_reg, 2);
                            });
                            if (sse_ref < sse_reg) {
                                shouldUseTheoretical = true;
                                ruleApplied = true;
                            }
                        }
                    }
                                        
                    if (shouldUseTheoretical) {
                        s_final = s_normative;
                        fcm_final = fcm_base;
                    } else {
                        s_final = reg_s_final;
                        fcm_final = reg_fcm_limited;
                    }

                    safetyOffset = this.computeOffsetResiduals(realData, fcm_final, s_final).maxPos;
                }
                                
                return { 
                    fcm: fcm_final, s: s_final, offset: safetyOffset, fcm_base, ruleApplied,
                    showPlausibleTrendCurve, plausibleTrendFcm, plausibleTrendS, plausibleTrendOffset, tendencySuperiority,
                    showFreeTrendCurve, freeTrendFcm, freeTrendS, freeTrendOffset
                };
            }
        };

        const App = {
            store: {
                state: {},
                listeners: [],
                getState() { return this.state; },
                subscribe(listener) { this.listeners.push(listener); },
                commit(mutation, payload) {
                    this.state = { ...this.state, [mutation]: payload };
                    this.listeners.forEach(listener => listener(this.state));
                }
            },
            nodes: {},
            chartInstance: null,

            init() {
                this.nodes = {
                    ctx: document.getElementById('resistanceChart').getContext('2d'),
                    fckInput: document.getElementById('fckInput'),
                    sdInput: document.getElementById('sdInput'),
                    cementType: document.getElementById('cementType'),
                    customSContainer: document.getElementById('customSContainer'),
                    customSInput: document.getElementById('customSInput'),
                    analysisMode: document.getElementById('analysisMode'),
                    dataTableBody: document.getElementById('dataTableBody'),
                    addPointBtn: document.getElementById('addPointBtn'),
                    predictionDays: document.getElementById('predictionDays'),
                    predictedResistanceDisplay: document.getElementById('predictedResistance'),
                    predictedPlausibleTrendResistanceContainer: document.getElementById('predictedPlausibleTrendResistanceContainer'),
                    predictedPlausibleTrendResistance: document.getElementById('predictedPlausibleTrendResistance'),
                    predictedFreeTrendResistanceContainer: document.getElementById('predictedFreeTrendResistanceContainer'),
                    predictedFreeTrendResistance: document.getElementById('predictedFreeTrendResistance'),
                    guidanceBox: document.getElementById('guidanceBox'),
                    warningsBox: document.getElementById('warningsBox'),
                    trendGuidanceBox: document.getElementById('trendGuidanceBox'),
                    delta28Box: document.getElementById('delta28Box'),
                    autoDropToggle: document.getElementById('autoDropToggle'),
                    excludedList: document.getElementById('excludedList'),
                    equationsSection: document.getElementById('equationsSection'),
                    theoreticalEquationDiv: document.getElementById('theoreticalEquation'),
                    characteristicEquationDiv: document.getElementById('characteristicEquation'),
                    plausibleTrendEquationContainer: document.getElementById('plausibleTrendEquationContainer'),
                    plausibleTrendEquation: document.getElementById('plausibleTrendEquation'),
                    freeTrendEquationContainer: document.getElementById('freeTrendEquationContainer'),
                    freeTrendEquation: document.getElementById('freeTrendEquation'),
                    generateReportBtn: document.getElementById('generateReportBtn'),
                    reportModal: document.getElementById('reportModal'),
                    reportContent: document.getElementById('reportContent'),
                    closeReportBtn: document.getElementById('closeReportBtn'),
                    importCsvBtn: document.getElementById('importCsvBtn'),
                    csvFileInput: document.getElementById('csvFileInput'),
                    exportPdfBtn: document.getElementById('exportPdfBtn'),
                    captureArea: document.getElementById('captureArea')
                };

                this.store.state = {
                    fck: parseFloat(this.nodes.fckInput.value) || 25,
                    sd: parseFloat(this.nodes.sdInput.value) || 4.0,
                    cementTypeValue: this.nodes.cementType.value,
                    customSValue: parseFloat(this.nodes.customSInput.value),
                    analysisMode: this.nodes.analysisMode.value,
                    realData: [],
                    predictionDays: parseFloat(this.nodes.predictionDays.value) || null,
                    analysisResults: null,
                    dataWarnings: [],
                    autoDropLessConservative: false,
                    excludedForFit: [],
                };

                this.initializeChart();
                this.bindEvents();
                this.store.subscribe(this.update.bind(this));
                this.update(this.store.getState());
            },
                        
            initializeChart() {
                this.chartInstance = new Chart(this.nodes.ctx, {
                    type: 'line',
                    data: { datasets: [
                        { label: 'Referência', data: [], borderColor: 'rgba(59, 130, 246, 0.7)', borderWidth: 2, pointRadius: 0, tension: 0.4, fill: false, borderDash: [5, 5], cubicInterpolationMode: 'monotone' },
                        { label: 'Curva Característica (Limitada)', data: [], borderColor: 'rgba(220, 38, 38, 1)', borderWidth: 3, pointRadius: 0, tension: 0.4, fill: false, cubicInterpolationMode: 'monotone' },
                        { type: 'scatter', label: 'Resultados Reais (Ensaio)', data: [], backgroundColor: 'rgba(239, 68, 68, 1)', borderColor: 'rgba(220, 38, 38, 1)', pointRadius: 6, pointHoverRadius: 8, z: 10 },
                        { label: 'Tendência Plausível (s restrito)', data: [], borderColor: 'rgba(34, 197, 94, 0.8)', borderWidth: 3, pointRadius: 0, tension: 0.4, fill: false, borderDash: [6, 3], hidden: true, cubicInterpolationMode: 'monotone' },
                        { label: 'Tendência Livre (s livre)', data: [], borderColor: 'rgba(124, 58, 237, 0.8)', borderWidth: 2, pointRadius: 0, tension: 0.4, fill: false, borderDash: [2, 2], hidden: true, cubicInterpolationMode: 'monotone' }
                    ]},
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: {
                            x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Idade do Concreto (dias)', font: { size: 12 } }, min: 0 },
                            y: { title: { display: true, text: 'Resistência (MPa)', font: { size: 12 } }, beginAtZero: true }
                        },
                        plugins: {
                            legend: { position: 'bottom', align: 'start', labels: { boxWidth: 20, padding: 15, font: { size: 10 } } },
                            tooltip: {
                                mode: 'x',
                                 intersect: false,
                                callbacks: {
                                    title: (tooltipItems) => {
                                        if (tooltipItems.length > 0) {
                                            const age = tooltipItems[0].parsed.x;
                                            return `Idade: ${age.toFixed(1)} dias`;
                                        }
                                        return '';
                                    },
                                    label: (context) => {
                                        let label = context.dataset.label || '';
                                        if (context.parsed.y !== null) {
                                            if (context.dataset.type === 'scatter') {
                                                 label = `Ensaio (${context.parsed.x}d): ${context.parsed.y.toFixed(2)} MPa`;
                                            } else {
                                                 label = `${label}: ${context.parsed.y.toFixed(2)} MPa`;
                                            }
                                        }
                                        return label;
                                    }
                                }
                            },
                            annotation: { annotations: { 
                                fckLine: { type: 'line', yMin: 0, yMax: 0, borderColor: 'rgba(245, 158, 11, 1)', borderWidth: 2, borderDash: [10, 5], label: { content: '', enabled: true, position: 'end', backgroundColor: 'rgba(245, 158, 11, 0.8)', color: 'white', font: { size: 10 } } },
                                predicted28dLine: { type: 'line', scaleID: 'x', value: 28, borderColor: 'rgba(220, 38, 38, 0.5)', borderWidth: 2, borderDash: [2,2], label: { content: 'Prev. 28d', enabled: false, position: 'start', backgroundColor: 'rgba(220, 38, 38, 0.8)' } },
                                real28dPoint: { type: 'point', scaleID: 'y', xValue: 28, yValue: 0, backgroundColor: 'rgba(245, 158, 11, 1)', radius: 6, enabled: false }
                            } }
                        }
                    }
                });
            },

            bindEvents() {
                const debounce = (func, delay) => {
                    let timeout;
                    return (...args) => {
                        clearTimeout(timeout);
                        timeout = setTimeout(() => func.apply(this, args), delay);
                    };
                };
                                
                const debouncedUpdate = debounce((key, value) => this.store.commit(key, value), 300);

                this.nodes.fckInput.addEventListener('input', (e) => debouncedUpdate('fck', parseFloat(e.target.value)));
                this.nodes.sdInput.addEventListener('input', (e) => debouncedUpdate('sd', parseFloat(e.target.value) || 4.0));
                
                this.nodes.cementType.addEventListener('change', (e) => {
                    const value = e.target.value;
                    if (value === 'custom') {
                        this.nodes.customSContainer.classList.remove('hidden');
                    } else {
                        this.nodes.customSContainer.classList.add('hidden');
                    }
                    this.store.commit('cementTypeValue', value);
                });
                this.nodes.customSInput.addEventListener('input', (e) => debouncedUpdate('customSValue', parseFloat(e.target.value)));

                this.nodes.analysisMode.addEventListener('change', (e) => this.store.commit('analysisMode', e.target.value));
                this.nodes.predictionDays.addEventListener('input', (e) => debouncedUpdate('predictionDays', parseFloat(e.target.value)));

                this.nodes.addPointBtn.addEventListener('click', () => {
                    const currentData = this.store.getState().realData;
                    const newData = [...currentData, { days: 7, mpa: 15 }];
                    this.store.commit('realData', newData);
                });

                this.nodes.dataTableBody.addEventListener('change', (e) => {
                    if (e.target.tagName === 'INPUT') {
                        const { index, prop } = e.target.dataset;
                        const currentData = this.store.getState().realData;
                        const newData = currentData.map((item, i) => i == index ? { ...item, [prop]: parseFloat(e.target.value) } : item);
                        this.store.commit('realData', newData);
                    }
                });

                this.nodes.dataTableBody.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-btn')) {
                        const { index } = e.target.dataset;
                        const currentData = this.store.getState().realData;
                        const newData = currentData.filter((_, i) => i != index);
                        this.store.commit('realData', newData);
                    }
                });

                this.nodes.autoDropToggle.addEventListener('change', (e) =>
                  this.store.commit('autoDropLessConservative', !!e.target.checked)
                );
                                
                this.bindModalEvents();
            },
                        
            update(state) {
                try {
                    const s_normative = state.cementTypeValue === 'custom' 
                        ? Calculator.validateInput(state.customSValue, "S Personalizado", 0.05, 0.6)
                        : parseFloat(state.cementTypeValue);
                    
                    const stateWithResolvedS = {...state, s_normative };

                    Calculator.validateInput(state.fck, "FCK de Projeto", 10, 150);
                    Calculator.validateInput(state.sd, "Desvio Padrão", 2.0);
                    
                    const dataWarnings = DataValidator.checkAll(state.realData, s_normative);
                    this.store.state.dataWarnings = dataWarnings; 
                    
                    let drops = [];
                    if(state.autoDropLessConservative){
                      drops = DataValidator.suggestDropsForFit(state.realData.sort((a,b)=>a.days-b.days), s_normative);
                    }
                    const realDataForFit = state.realData.filter(p => !drops.includes(p.days));

                    const analysisResults = Calculator.performAnalysis({
                      ...stateWithResolvedS, realData: realDataForFit
                    });
                                        
                    this.store.state.analysisResults = analysisResults;
                    this.store.state.excludedForFit = drops;

                    this.render(this.store.getState());

                } catch (error) {
                    this.nodes.guidanceBox.className = 'p-3 mb-4 text-sm rounded-lg bg-red-100 text-red-800';
                    this.nodes.guidanceBox.innerHTML = `<b>Erro de Validação:</b> ${error.message}`;
                }
            },

            render(state) {
                this.renderChart(state);
                this.renderTable(state);
                this.renderGuidance(state);
                this.renderWarnings(state); 
                this.renderEquations(state);
                this.renderPrediction(state);
                this.renderDelta28(state);
                this.nodes.generateReportBtn.disabled = state.realData.length === 0;
                this.nodes.exportPdfBtn.disabled = state.realData.length === 0;
            },
                        
            renderChart(state) {
                const { analysisResults, fck, realData } = state;
                if (!analysisResults || !this.chartInstance) return;

                const s_normative = state.cementTypeValue === 'custom' ? state.customSValue : parseFloat(state.cementTypeValue);

                const theoreticalCurve = Calculator.generateCurveData(analysisResults.fcm_base, s_normative);
                const characteristicCurve = Calculator.generateCurveData(analysisResults.fcm, analysisResults.s).map(p => ({ x: p.x, y: Math.max(0, p.y - analysisResults.offset) }));
                                
                this.chartInstance.data.datasets[0].data = theoreticalCurve;
                this.chartInstance.data.datasets[0].label = `Referência (${this.nodes.cementType.options[this.nodes.cementType.selectedIndex].text})`;
                this.chartInstance.data.datasets[1].data = characteristicCurve;
                this.chartInstance.data.datasets[2].data = realData.map(p => ({ x: p.days, y: p.mpa }));
                                
                const plausibleTrendCurve = analysisResults.showPlausibleTrendCurve 
                    ? Calculator.generateCurveData(analysisResults.plausibleTrendFcm, analysisResults.plausibleTrendS).map(p => ({ x: p.x, y: Math.max(0, p.y - analysisResults.plausibleTrendOffset) }))
                    : [];
                this.chartInstance.data.datasets[3].data = plausibleTrendCurve;
                this.chartInstance.data.datasets[3].hidden = !analysisResults.showPlausibleTrendCurve;

                const freeTrendCurve = analysisResults.showFreeTrendCurve 
                    ? Calculator.generateCurveData(analysisResults.freeTrendFcm, analysisResults.freeTrendS).map(p => ({ x: p.x, y: Math.max(0, p.y - analysisResults.freeTrendOffset) }))
                    : [];
                this.chartInstance.data.datasets[4].data = freeTrendCurve;
                this.chartInstance.data.datasets[4].hidden = !analysisResults.showFreeTrendCurve;

                this.chartInstance.options.plugins.annotation.annotations.fckLine.yMin = fck;
                this.chartInstance.options.plugins.annotation.annotations.fckLine.yMax = fck;
                this.chartInstance.options.plugins.annotation.annotations.fckLine.label.content = `fck = ${fck} MPa`;
                
                // Indicador de 28 dias
                const p28 = state.realData.find(p => p.days === 28);
                const pred28dLine = this.chartInstance.options.plugins.annotation.annotations.predicted28dLine;
                const real28dPoint = this.chartInstance.options.plugins.annotation.annotations.real28dPoint;
                if (p28) {
                    pred28dLine.enabled = true;
                    real28dPoint.enabled = true;
                    real28dPoint.yValue = p28.mpa;
                } else {
                    pred28dLine.enabled = false;
                    real28dPoint.enabled = false;
                }
                                
                this.chartInstance.update('none');
            },

            renderTable(state) {
                this.nodes.dataTableBody.innerHTML = '';
                state.realData.forEach((point, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `<td class="px-2 py-1"><input type="number" value="${point.days}" data-index="${index}" data-prop="days" class="w-full bg-gray-50 border-gray-200 rounded py-1 px-2 text-sm"></td><td class="px-2 py-1"><input type="number" step="0.1" value="${point.mpa}" data-index="${index}" data-prop="mpa" class="w-full bg-gray-50 border-gray-200 rounded py-1 px-2 text-sm"></td><td class="px-2 py-1 text-right"><button data-index="${index}" class="remove-btn text-red-600 hover:text-red-900 text-sm">Remover</button></td>`;
                    this.nodes.dataTableBody.appendChild(row);
                });
            },
                        
            renderGuidance(state) {
                const { analysisResults, analysisMode, realData } = state;
                if (!analysisResults) return;

                let message = '';
                let bgColor = 'bg-gray-100';
                let textColor = 'text-gray-800';

                if (realData.length === 0) {
                    message = 'Adicione pelo menos um resultado de ensaio para iniciar a análise.';
                } else if (analysisResults.ruleApplied) {
                    message = `<b>Aviso de Análise:</b> A curva de referência teórica foi adotada. Motivo: os resultados dos ensaios superam a previsão teórica e o modelo teórico demonstrou um ajuste matemático superior ao da regressão para os dados fornecidos.`;
                    bgColor = 'bg-purple-100'; textColor = 'text-purple-800';
                } else {
                    let fcmMessagePart = `fcm ajustado: ${analysisResults.fcm.toFixed(1)} MPa`;
                    if (analysisResults.fcm < analysisResults.fcm_base && analysisResults.showPlausibleTrendCurve) {
                       fcmMessagePart = `fcm: ${analysisResults.fcm.toFixed(1)} MPa (limitado)`;
                    }

                    if (analysisMode === 'normative') {
                        message = `<b>Análise Normativa (${fcmMessagePart}):</b> A forma da curva segue o padrão NBR 6118. A altura foi ajustada aos seus dados.`;
                        bgColor = 'bg-blue-100'; textColor = 'text-blue-800';
                    } else {
                         if (realData.length < 2) {
                            message = `<b>Diagnóstico Inicial (fcm estimado: ${analysisResults.fcm.toFixed(1)} MPa):</b> A previsão usa o 's' normativo. Adicione mais pontos para uma análise otimizada.`;
                            bgColor = 'bg-yellow-100'; textColor = 'text-yellow-800';
                         } else {
                            message = `<b>Análise Otimizada (${fcmMessagePart}, s: ${analysisResults.s.toFixed(3)}):</b> A curva foi otimizada com base na tendência real dos seus dados.`;
                            bgColor = 'bg-green-100'; textColor = 'text-green-800';
                            if (analysisResults.showPlausibleTrendCurve) {
                                bgColor = 'bg-yellow-100'; textColor = 'text-yellow-800';
                            }
                         }
                    }
                }
                this.nodes.guidanceBox.className = `p-3 mb-2 text-sm rounded-lg ${bgColor} ${textColor}`;
                this.nodes.guidanceBox.innerHTML = message;

                if (analysisResults.showPlausibleTrendCurve) {
                    this.nodes.trendGuidanceBox.innerHTML = `<b>Tendência Superior:</b> A regressão plausível indica um potencial de resistência <b>${analysisResults.tendencySuperiority.toFixed(1)}% maior</b> que a referência aos 28 dias. A Curva Característica foi limitada por segurança.`;
                    this.nodes.trendGuidanceBox.className = 'p-3 mb-4 text-sm rounded-lg bg-teal-100 text-teal-800';
                    this.nodes.trendGuidanceBox.classList.remove('hidden');
                } else {
                    this.nodes.trendGuidanceBox.classList.add('hidden');
                }
            },

            renderWarnings(state) {
                const { dataWarnings, excludedForFit } = state;
                const hasWarnings = dataWarnings && dataWarnings.length > 0;
                const hasExclusions = excludedForFit && excludedForFit.length > 0;

                if (!hasWarnings && !hasExclusions) {
                    this.nodes.warningsBox.innerHTML = '';
                    this.nodes.warningsBox.classList.add('hidden');
                    this.nodes.excludedList.classList.add('hidden');
                    return;
                }
                
                if (hasWarnings) {
                    const warningsHtml = dataWarnings.map(msg => `<div class="p-3 text-sm rounded-lg bg-yellow-100 text-yellow-800">${msg}</div>`).join('');
                    this.nodes.warningsBox.innerHTML = warningsHtml;
                    this.nodes.warningsBox.classList.remove('hidden');
                } else {
                    this.nodes.warningsBox.classList.add('hidden');
                }

                if (hasExclusions) {
                  this.nodes.excludedList.classList.remove('hidden');
                  this.nodes.excludedList.innerHTML = 
                    `Pontos excluídos do <b>ajuste</b> (heurística conservadora): ` +
                    excludedForFit.sort((a,b)=>a-b).map(d=>`${d}d`).join(', ') +
                    `. Os dados permanecem visíveis no gráfico/tabela.`;
                } else {
                  this.nodes.excludedList.classList.add('hidden');
                  this.nodes.excludedList.innerHTML = '';
                }
            },

            renderEquations(state) {
                const { analysisResults } = state;
                 if (!analysisResults || !analysisResults.s || !analysisResults.fcm) {
                    this.nodes.equationsSection.classList.add('hidden');
                    return;
                }
                
                const s_normative = state.cementTypeValue === 'custom' ? state.customSValue : parseFloat(state.cementTypeValue);

                this.nodes.equationsSection.classList.remove('hidden');
                
                const th_eq = `f_{cm,ref}(t) = ${analysisResults.fcm_base.toFixed(2)} \\cdot e^{\\left[${s_normative.toFixed(3)} \\cdot \\left(1 - \\sqrt{28/t}\\right)\\right]}`;
                const ch_eq = `f_{ck,est}(t) = \\left( ${analysisResults.fcm.toFixed(2)} \\cdot e^{\\left[${analysisResults.s.toFixed(3)} \\cdot \\left(1 - \\sqrt{28/t}\\right)\\right]} \\right) - ${analysisResults.offset.toFixed(2)}`;
                katex.render(th_eq, this.nodes.theoreticalEquationDiv, { throwOnError: false });
                katex.render(ch_eq, this.nodes.characteristicEquationDiv, { throwOnError: false });

                if (analysisResults.showPlausibleTrendCurve) {
                    const pl_eq = `f_{ck,tend}(t) = \\left( ${analysisResults.plausibleTrendFcm.toFixed(2)} \\cdot e^{\\left[${analysisResults.plausibleTrendS.toFixed(3)} \\cdot \\left(1 - \\sqrt{28/t}\\right)\\right]} \\right) - ${analysisResults.plausibleTrendOffset.toFixed(2)}`;
                    katex.render(pl_eq, this.nodes.plausibleTrendEquation, { throwOnError: false });
                    this.nodes.plausibleTrendEquationContainer.classList.remove('hidden');
                } else {
                    this.nodes.plausibleTrendEquationContainer.classList.add('hidden');
                }
                
                if (analysisResults.showFreeTrendCurve) {
                    const fr_eq = `f_{ck,livre}(t) = \\left( ${analysisResults.freeTrendFcm.toFixed(2)} \\cdot e^{\\left[${analysisResults.freeTrendS.toFixed(3)} \\cdot \\left(1 - \\sqrt{28/t}\\right)\\right]} \\right) - ${analysisResults.freeTrendOffset.toFixed(2)}`;
                    katex.render(fr_eq, this.nodes.freeTrendEquation, { throwOnError: false });
                    this.nodes.freeTrendEquationContainer.classList.remove('hidden');
                } else {
                    this.nodes.freeTrendEquationContainer.classList.add('hidden');
                }
            },

            renderPrediction(state) {
                const { analysisResults, predictionDays } = state;
                if (!analysisResults || isNaN(predictionDays) || predictionDays <= 0) {
                    this.nodes.predictedResistanceDisplay.innerHTML = '-- MPa';
                    this.nodes.predictedPlausibleTrendResistanceContainer.classList.add('hidden');
                    this.nodes.predictedFreeTrendResistanceContainer.classList.add('hidden');
                    return;
                }
                                
                const meanResistance = Calculator.calculateResistance(analysisResults.fcm, analysisResults.s, predictionDays);
                const characteristicResistance = Math.max(0, meanResistance - analysisResults.offset);
                this.nodes.predictedResistanceDisplay.innerHTML = `${characteristicResistance.toFixed(2)} MPa`;

                if (analysisResults.showPlausibleTrendCurve) {
                    const trendMeanResistance = Calculator.calculateResistance(analysisResults.plausibleTrendFcm, analysisResults.plausibleTrendS, predictionDays);
                    const trendCharacteristicResistance = Math.max(0, trendMeanResistance - analysisResults.plausibleTrendOffset);
                    this.nodes.predictedPlausibleTrendResistance.innerHTML = `${trendCharacteristicResistance.toFixed(2)} MPa`;
                    this.nodes.predictedPlausibleTrendResistanceContainer.classList.remove('hidden');
                } else {
                    this.nodes.predictedPlausibleTrendResistanceContainer.classList.add('hidden');
                }
                
                if (analysisResults.showFreeTrendCurve) {
                    const freeTrendMeanResistance = Calculator.calculateResistance(analysisResults.freeTrendFcm, analysisResults.freeTrendS, predictionDays);
                    const freeTrendCharacteristicResistance = Math.max(0, freeTrendMeanResistance - analysisResults.freeTrendOffset);
                    this.nodes.predictedFreeTrendResistance.innerHTML = `${freeTrendCharacteristicResistance.toFixed(2)} MPa`;
                    this.nodes.predictedFreeTrendResistanceContainer.classList.remove('hidden');
                } else {
                    this.nodes.predictedFreeTrendResistanceContainer.classList.add('hidden');
                }
            },
            
            renderDelta28(state) {
                const p28 = state.realData.find(p => p.days === 28);
                const ar = state.analysisResults;
                if (!p28 || !ar) {
                    this.nodes.delta28Box.classList.add('hidden');
                    return;
                }
                
                const mean28 = Calculator.calculateResistance(ar.fcm, ar.s, 28);
                const ck28 = Math.max(0, mean28 - ar.offset);
                const err = ((ck28 - p28.mpa) / p28.mpa) * 100;
                
                const message = `<b>Acurácia vs. 28d Real:</b> <span class="font-bold ${err > 0 ? 'text-red-600' : 'text-green-600'}">${err.toFixed(1)}%</span> (${err > 0 ? 'superestimou' : 'conservador'})`;
                const bgColor = err > 5 ? 'bg-red-100 text-red-800' : err < -5 ? 'bg-blue-100 text-blue-800' : 'bg-green-100 text-green-800';
                
                this.nodes.delta28Box.className = `p-3 mb-4 text-sm rounded-lg ${bgColor}`;
                this.nodes.delta28Box.innerHTML = message;
                this.nodes.delta28Box.classList.remove('hidden');
            },

            bindModalEvents() {
                this.nodes.generateReportBtn.addEventListener('click', () => {
                    this.generateReport();
                    this.nodes.reportModal.classList.remove('hidden', 'opacity-0');
                    this.nodes.reportModal.querySelector('.modal-content').classList.remove('scale-95');
                });
                this.nodes.closeReportBtn.addEventListener('click', () => {
                    this.nodes.reportModal.classList.add('opacity-0');
                    this.nodes.reportModal.querySelector('.modal-content').classList.add('scale-95');
                    setTimeout(() => this.nodes.reportModal.classList.add('hidden'), 300);
                });
                                
                this.nodes.importCsvBtn.addEventListener('click', () => this.nodes.csvFileInput.click());
                this.nodes.csvFileInput.addEventListener('change', this.handleCsvImport.bind(this));
                this.nodes.exportPdfBtn.addEventListener('click', this.handlePdfExport.bind(this));
            },
                        
            generateReport() {
                const { analysisResults, fck, sd } = this.store.getState();
                if (!analysisResults) {
                    this.nodes.reportContent.innerHTML = '<p>Dados insuficientes para gerar o relatório.</p>';
                    return;
                }
                const s_normative = this.store.state.cementTypeValue === 'custom' ? this.store.state.customSValue : parseFloat(this.store.state.cementTypeValue);
                const { fcm, s, fcm_base, offset } = analysisResults;
                const fck_est_28 = Calculator.calculateResistance(fcm, s, 28) - offset;

                let diagnosis = '', performance = '', causes = '', recommendations = '';

                if (fck_est_28 >= fck) {
                    diagnosis = `<div class="p-3 text-green-800 bg-green-100 rounded-lg"><b>Diagnóstico Geral: Satisfatório.</b> O concreto demonstra um desempenho compatível com o esperado, e a projeção indica que a resistência de projeto (fck = ${fck} MPa) será atingida aos 28 dias (fck,est = ${fck_est_28.toFixed(1)} MPa).</div>`;
                } else {
                    diagnosis = `<div class="p-3 text-yellow-800 bg-yellow-100 rounded-lg"><b>Diagnóstico Geral: Alerta.</b> O concreto apresenta desempenho abaixo do esperado. A projeção indica que a resistência de projeto (fck = ${fck} MPa) <b>não</b> será atingida aos 28 dias (fck,est = ${fck_est_28.toFixed(1)} MPa).</div>`;
                }

                const s_comparison_text = s.toFixed(3) < s_normative.toFixed(3) ?
                    `<b>mais rápido</b> (s=${s.toFixed(3)}) que o normativo (s=${s_normative.toFixed(3)}).` :
                    s.toFixed(3) > s_normative.toFixed(3) ?
                    `<b>mais lento</b> (s=${s.toFixed(3)}) que o normativo (s=${s_normative.toFixed(3)}).` :
                    `<b>equivalente</b> (s=${s.toFixed(3)}) ao normativo (s=${s_normative.toFixed(3)}).`;
                
                const fcm_comparison_text = fcm < fcm_base ?
                    `<b>inferior</b> (fcm,real = ${fcm.toFixed(1)} MPa) ao potencial teórico do traço (fcm,teórico = ${fcm_base.toFixed(1)} MPa).` :
                    `<b>compatível ou superior</b> (fcm,real = ${fcm.toFixed(1)} MPa) ao potencial teórico (fcm,teórico = ${fcm_base.toFixed(1)} MPa).`;

                performance = `<h4 class="font-semibold mt-4">Análise de Desempenho e Correlações</h4>
                                <p>A análise da curva característica do concreto, baseada nos ensaios, revela os seguintes comportamentos:</p>
                                <ul class="list-disc list-inside space-y-1 mt-2">
                                     <li><b>Velocidade de Ganho de Resistência (Parâmetro 's'):</b> O ganho de resistência está ocorrendo de forma ${s_comparison_text}</li>
                                     <li><b>Resistência Potencial Média (Parâmetro 'fcm'):</b> A resistência potencial do concreto em si é ${fcm_comparison_text}</li>
                                </ul>`;
                
                if (fck_est_28 < fck) {
                    causes = `<h4 class="font-semibold mt-4">Possíveis Causas para o Baixo Desempenho:</h4>
                                <ul class="list-disc list-inside space-y-1 mt-2">
                                     <li><b>Fator Principal (ligado ao fcm baixo):</b> Relação água/cimento (a/c) elevada; consumo de cimento abaixo do especificado; erro na pesagem dos materiais; qualidade dos agregados.</li>
                                     <li><b>Fatores Secundários (influenciam 's' e fcm):</b> Qualidade do cimento; temperatura; processo de cura inadequado; falhas no processo de execução.</li>
                                     <li><b>Fatores de Ensaio:</b> Não conformidades na moldagem, cura e rompimento dos corpos de prova (NBR 5738 e NBR 5739).</li>
                                </ul>`;
                    recommendations = `<h4 class="font-semibold mt-4">Recomendações (ABNT NBR 12655):</h4>
                                        <ul class="list-disc list-inside space-y-1 mt-2">
                                             <li><b>Ação Imediata:</b> Verificar os registros de dosagem e os relatórios de controle de qualidade da central de concreto.</li>
                                             <li><b>Investigação:</b> Inspecionar as condições de cura na estrutura e continuar o monitoramento com ensaios em idades futuras.</li>
                                             <li><b>Análise Estrutural:</b> Comunicar o projetista estrutural para avaliar a necessidade de ensaios complementares e definir as implicações para a segurança e durabilidade.</li>
                                        </ul>`;
                } else {
                    recommendations = `<h4 class="font-semibold mt-4">Recomendações:</h4>
                                        <ul class="list-disc list-inside space-y-1 mt-2">
                                             <li>Manter o plano de controle tecnológico e os procedimentos de execução que levaram ao bom resultado.</li>
                                             <li>O desempenho satisfatório indica que a dosagem, os materiais e os processos de execução estão alinhados com as premissas de projeto.</li>
                                        </ul>`;
                }
                this.nodes.reportContent.innerHTML = `${diagnosis}${performance}${causes}${recommendations}`;
            },

            handleCsvImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const rows = text.replace(/\r/g,'').split('\n').slice(1);
                    const parseNum = (v) => parseFloat(String(v).trim().replace(',', '.'));
                    const newPoints = rows.map(row => {
                      const parts = row.split(/[;,]/).map(x => x.trim());
                      const dayNum = parseNum(parts[0]);
                      const mpaNum = parseNum(parts[1]);
                      return (!isNaN(dayNum) && !isNaN(mpaNum) && dayNum>0 && mpaNum>0) ? {days: dayNum, mpa: mpaNum} : null;
                    }).filter(Boolean);
                    
                    const aggregateByDay = (points) => {
                      const byDay = new Map();
                      points.forEach(p=>{
                        const k = Number(p.days);
                        if(!byDay.has(k)) byDay.set(k, []);
                        byDay.get(k).push(Number(p.mpa));
                      });
                      const agg = [];
                      for(const [days, arr] of byDay.entries()){
                        arr.sort((a,b)=>a-b);
                        const mid = Math.floor(arr.length/2);
                        const med = (arr.length%2)?arr[mid]:(0.5*(arr[mid-1]+arr[mid]));
                        agg.push({days, mpa: med});
                      }
                      return agg.sort((a,b)=>a.days-b.days);
                    }
                                        
                    if (newPoints.length > 0) {
                        const merged = aggregateByDay([...this.store.getState().realData, ...newPoints]);
                        this.store.commit('realData', merged);
                    } else {
                        alert("Nenhum dado válido encontrado no arquivo CSV. O formato esperado é 'idade,resistencia' em cada linha.");
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            },
                        
            async handlePdfExport() {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                const state = this.store.getState();
                const { analysisResults, fck, sd, realData } = state;

                if (!analysisResults || realData.length === 0) {
                    alert("Dados insuficientes para gerar o relatório.");
                    return;
                }
                
                const s_normative = state.cementTypeValue === 'custom' ? state.customSValue : parseFloat(state.cementTypeValue);

                this.nodes.exportPdfBtn.textContent = "Gerando PDF...";
                this.nodes.exportPdfBtn.disabled = true;

                try {
                    doc.setFontSize(18);
                    doc.text("Relatório de Análise Preditiva de Resistência", 105, 15, { align: 'center' });

                    doc.setFontSize(11);
                    doc.text(`Data de Emissão: ${new Date().toLocaleDateString('pt-BR')}`, 14, 25);
                    doc.line(14, 27, 196, 27);

                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.text("Parâmetros de Entrada", 14, 35);
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(10);
                    const cementText = this.nodes.cementType.options[this.nodes.cementType.selectedIndex].text;
                    doc.text(`- Resistência de Projeto (fck): ${fck} MPa`, 16, 42);
                    doc.text(`- Desvio Padrão de Dosagem (sd): ${sd.toFixed(1)} MPa`, 16, 47);
                    doc.text(`- Tipo de Cimento (NBR 6118): ${cementText}`, 16, 52);
                    doc.text(`- Coeficiente Normativo (s): ${s_normative.toFixed(3)}`, 16, 57);
                                        
                    const canvas = await html2canvas(this.nodes.captureArea, { scale: 2.5 });
                    const imgData = canvas.toDataURL('image/png');

                    const pageContentWidth = 182; 
                    const topMargin = 65; 
                    const bottomMargin = 85; 
                    const maxChartHeight = doc.internal.pageSize.height - topMargin - bottomMargin;

                    let pdfWidth = pageContentWidth;
                    let pdfHeight = pdfWidth * (canvas.height / canvas.width); 
                    
                    if (pdfHeight > maxChartHeight) {
                        pdfHeight = maxChartHeight;
                        pdfWidth = pdfHeight * (canvas.width / canvas.height);
                    }
                                        
                    const pdfX = 14 + (pageContentWidth - pdfWidth) / 2;

                    doc.addImage(imgData, 'PNG', pdfX, topMargin, pdfWidth, pdfHeight);

                    const chartBottomY = topMargin + pdfHeight;

                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.text("Equações Aplicadas", 14, chartBottomY + 10);
                                        
                    const th_eq_string = `f_{cm,ref}(t) = ${analysisResults.fcm_base.toFixed(2)} \\cdot e^{\\left[${s_normative.toFixed(3)} \\cdot \\left(1 - \\sqrt{28/t}\\right)\\right]}`;
                    const ch_eq_string = `f_{ck,est}(t) = \\left( ${analysisResults.fcm.toFixed(2)} \\cdot e^{\\left[${analysisResults.s.toFixed(3)} \\cdot \\left(1 - \\sqrt{28/t}\\right)\\right]} \\right) - ${analysisResults.offset.toFixed(2)}`;

                    let currentY = await this.addKatexToPdf(doc, th_eq_string, 14, chartBottomY + 20, "Curva de Referência (Teórica):");
                    currentY = await this.addKatexToPdf(doc, ch_eq_string, 14, currentY, "Curva Característica (Estimada):");

                    if (analysisResults.showPlausibleTrendCurve) {
                        const pl_eq_string = `f_{ck,tend}(t) = \\left( ${analysisResults.plausibleTrendFcm.toFixed(2)} \\cdot e^{\\left[${analysisResults.plausibleTrendS.toFixed(3)} \\cdot \\left(1 - \\sqrt{28/t}\\right)\\right]} \\right) - ${analysisResults.plausibleTrendOffset.toFixed(2)}`;
                        currentY = await this.addKatexToPdf(doc, pl_eq_string, 14, currentY, "Curva de Tendência Plausível (s restrito):");
                    }
                    
                    if (analysisResults.showFreeTrendCurve) {
                        const fr_eq_string = `f_{ck,livre}(t) = \\left( ${analysisResults.freeTrendFcm.toFixed(2)} \\cdot e^{\\left[${analysisResults.freeTrendS.toFixed(3)} \\cdot \\left(1 - \\sqrt{28/t}\\right)\\right]} \\right) - ${analysisResults.freeTrendOffset.toFixed(2)}`;
                        await this.addKatexToPdf(doc, fr_eq_string, 14, currentY, "Curva de Tendência Livre (s livre):");
                    }

                    doc.addPage();
                    doc.setFontSize(16);
                    doc.text("Diagnóstico Técnico e Recomendações", 105, 15, { align: 'center' });

                    this.generateReport(); 
                    await this.addHtmlToPdf(doc, this.nodes.reportContent.innerHTML, 14, 25);

                    doc.save(`relatorio-concreto-${new Date().toISOString().slice(0,10)}.pdf`);
                } catch (err) {
                    console.error("Erro ao gerar PDF:", err);
                    alert("Ocorreu um erro ao gerar o PDF.");
                } finally {
                    this.nodes.exportPdfBtn.textContent = "Exportar PDF";
                    this.nodes.exportPdfBtn.disabled = state.realData.length === 0;
                }
            },

            async addKatexToPdf(doc, latexString, x, y, title) {
                if (title) {
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(10);
                    doc.text(title, x, y - 4);
                }

                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                tempDiv.style.padding = '0px'; 
                tempDiv.style.margin = '0px';
                tempDiv.style.backgroundColor = 'white';
                tempDiv.style.color = 'black';
                tempDiv.style.display = 'inline-block';
                tempDiv.style.lineHeight = '1';

                document.body.appendChild(tempDiv);

                katex.render(latexString, tempDiv, { throwOnError: false, displayMode: true });
                                
                await new Promise(resolve => setTimeout(resolve, 100));

                const katexCanvas = await html2canvas(tempDiv, { scale: 3, backgroundColor: null });
                const imgData = katexCanvas.toDataURL('image/png');
                                
                const imgWidth = katexCanvas.width / 11.8;
                const imgHeight = katexCanvas.height / 11.8;
                                
                doc.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
                document.body.removeChild(tempDiv);
                return y + imgHeight + 8;
            },

            async addHtmlToPdf(doc, htmlContent, startX, startY) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                let yPos = startY;
                const pageHeight = doc.internal.pageSize.height;
                const bottomMargin = 20;

                const elements = Array.from(tempDiv.children);

                for (const el of elements) {
                    const checkPageBreak = (neededHeight) => {
                        if (yPos + neededHeight > pageHeight - bottomMargin) {
                            doc.addPage();
                            yPos = 15;
                        }
                    };

                    let text = el.innerText || el.textContent;
                    let leftMargin = startX;

                    if (el.tagName === 'H4') {
                        checkPageBreak(12);
                        yPos += 6;
                        doc.setFontSize(12);
                        doc.setFont('helvetica', 'bold');
                        const splitText = doc.splitTextToSize(text, 182);
                        doc.text(splitText, leftMargin, yPos);
                        yPos += (splitText.length * 4.5) + 2;
                    } else if (el.tagName === 'P') {
                        checkPageBreak(8);
                        doc.setFontSize(10);
                        doc.setFont('helvetica', 'normal');
                        const splitText = doc.splitTextToSize(text, 182);
                        doc.text(splitText, leftMargin, yPos);
                        yPos += (splitText.length * 4.5) + 2;
                    } else if (el.tagName === 'UL') {
                        checkPageBreak(10);
                        yPos += 2;
                        const listItems = Array.from(el.querySelectorAll('li'));
                        for (const li of listItems) {
                             doc.setFontSize(10);
                             doc.setFont('helvetica', 'normal');
                             const itemText = doc.splitTextToSize(li.innerText, 178);
                             checkPageBreak(itemText.length * 4.5);
                             doc.text(itemText, startX + 4, yPos, { charSpace: 0.1 });
                             yPos += (itemText.length * 4.5);
                             doc.text("•", startX, yPos - (itemText.length * 4.5));
                        }
                        yPos += 4;
                    } else if (el.tagName === 'DIV') {
                        doc.setFontSize(10);
                        doc.setFont('helvetica', 'normal');
                        const isSuccess = el.classList.contains('bg-green-100');
                        const bgColor = isSuccess ? '#F0FFF4' : '#FFFBEB';
                        const borderColor = isSuccess ? '#C6F6D5' : '#FEF3C7';
                        const textLines = doc.splitTextToSize(text, 178);
                        const boxHeight = (textLines.length * 4.5) + 6;
                        checkPageBreak(boxHeight);
                        doc.setDrawColor(borderColor);
                        doc.setFillColor(bgColor);
                        doc.rect(startX, yPos - 4, 182, boxHeight, 'FD');
                        doc.text(textLines, startX + 2, yPos);
                        yPos += boxHeight;
                    }
                }
            }
        };
                
        App.init();
    });
    </script>

</body>
</html>
